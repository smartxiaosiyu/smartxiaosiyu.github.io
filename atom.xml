<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>SmartXiaosiyu</title>
    <updated>2022-01-05T08:58:27.946Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>BugMaker</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2022, SmartXiaosiyu</rights>
    <entry>
        <title type="html"><![CDATA[iOS 内存]]></title>
        <id>http://localhost:4000/post/ios-nei-cun/</id>
        <link href="http://localhost:4000/post/ios-nei-cun/">
        </link>
        <updated>2021-12-15T09:37:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="内存布局">内存布局</h3>
<p><img src="http://localhost:4000/post-images/1639624670540.png" alt="" loading="lazy"><br>
代码段：编译之后的代码<br>
数据段： 字符串常量  已初始化数据：已初始化的全局变量、静态变量  未初始化数据：未初始化的全局变<br>
量、静态变量<br>
堆：alloc malloc动态分配的内存 分配内存的空间地址越来越大<br>
栈：函数调用开销，局部变量。分配的内存空间地址越来越小<br>
堆空间越来越大 栈空间越来越小</p>
<h3 id="tagged-point">Tagged Point</h3>
<ul>
<li>从64位开始，iOS引入了Tagged Point技术，用于优化NSNumber、NSDate、NSString等小对象的存储</li>
<li>在没有使用Tagged Point之前 NSNumber、NSDate、NSString他们是对象 需要动态分配内存，维护引用技术等 NSNumber指针指向的是堆中NSNumber对象的地址值 指针8个字节 对象16个字节 一共24个字节</li>
<li>使用 Tagged Point之后，NSNumber指针里存储的数据变成了：Tag+Data 数据直接存在指针中</li>
<li>但是当指针不够存储数据的时候 才会使用动态内存的方式来存储数据</li>
<li>obj_mgsend 可以识别出来如果是Tagged Point，直接从指针中取出值 不需要找到isa指向的类对象 再从类对象找方法 节省了内存开销 查找开销</li>
<li>如何判断一个指针是否为Tagged Pointer？<br>
iOS平台，最高有效位是1（第64bit）<br>
Mac平台，最低有效位是1<br>
<img src="http://localhost:4000/post-images/1639636465743.png" alt="" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1639735258084.png" alt="" loading="lazy"></figure>
<h3 id="copy">Copy</h3>
<p>拷贝的目的 产生一个新副本对象 修改了源对象 不会影响副本对象 反之亦然<br>
copy 就相当于 retain操作<br>
copy 不可变拷贝 产生不可变副本 浅拷贝 指针拷贝 计数器+1 的操作 没产生新对象<br>
mutableCopy 可变拷贝 产生可变副本  深拷贝 内容拷贝 产生新对象</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1640347715615.png" alt="" loading="lazy"></figure>
<p><img src="http://localhost:4000/post-images/1640416746636.jpeg" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1640416752678.jpeg" alt="" loading="lazy"></p>
<p>属性不可以是mutableCopy<br>
对象copy必须遵循Copying协议 是一个新的对象</p>
<h3 id="引用计数存储">引用计数存储</h3>
<p><img src="http://localhost:4000/post-images/1640503801508.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1640503821772.png" alt="" loading="lazy"><br>
如果extra_rc 存不下引用计数的值 has_sidetable_rc变成1 就会 存储在SideTable类中<br>
<img src="http://localhost:4000/post-images/1640693158136.png" alt="" loading="lazy"><br>
获取 引用计数值<br>
<img src="http://localhost:4000/post-images/1640504815778.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1640504823834.png" alt="" loading="lazy"></p>
<p>retain<br>
<img src="http://localhost:4000/post-images/1640504834582.png" alt="" loading="lazy"><br>
release<br>
<img src="http://localhost:4000/post-images/1640504842986.png" alt="" loading="lazy"></p>
<h3 id="weak指针">weak指针</h3>
<p>weak指针指向的对象如果释放了，则这个指针会自动释放<br>
将弱引用存到哈希里 当对象释放的时候 清空weak指针</p>
<h3 id="arc">ARC</h3>
<p>LLVM和runtime系统相互协作的一个结果<br>
利用LLVM编译器帮我们自动release<br>
弱引用是利用runtime</p>
<h3 id="dealloc">Dealloc</h3>
<p><img src="http://localhost:4000/post-images/1640693014995.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1640693452325.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1640693461628.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1640693467045.png" alt="" loading="lazy"></p>
<h3 id="autoreleasepool">AutoReleasePool</h3>
<p><img src="http://localhost:4000/post-images/1641282087999.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1641282100148.png" alt="" loading="lazy"></p>
<p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址<br>
所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起<br>
<img src="http://localhost:4000/post-images/1641282280295.png" alt="" loading="lazy"><br>
调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</p>
<p>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY</p>
<p>id *next指向了下一个能存放autorelease对象地址的区域</p>
<h3 id="runloop和autorelease">Runloop和Autorelease</h3>
<ul>
<li>autorelease对象在什么时机会被调用release？？<br>
iOS在主线程的Runloop中注册了2个Observer<br>
第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()<br>
第2个Observer<br>
监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()<br>
监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()</li>
<li>方法里有局部对象， 出了方法后会立即释放吗<br>
MRC的话 RunloopkCFRunLoopBeforeWaiting或者kCFRunLoopBeforeExit 时候释放<br>
ARC的话 默认函数内就释放 因为函数结束前调用release</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 分类]]></title>
        <id>http://localhost:4000/post/ios-fen-lei/</id>
        <link href="http://localhost:4000/post/ios-fen-lei/">
        </link>
        <updated>2021-12-13T07:58:22.000Z</updated>
        <content type="html"><![CDATA[<p>编译出来的结果<br>
<img src="http://localhost:4000/post-images/1639382328780.png" alt="" loading="lazy"></p>
<p>运行时<br>
将 rw-&gt;methods 指向的数组扩容，将原来的方法列表移到最后，add分类到数组里，优先调用最后面编译的分类，再调用原来的方法</p>
<h3 id="category的加载处理过程">Category的加载处理过程</h3>
<p>通过Runtime加载某个类的所有Category数据</p>
<p>把所有Category的方法、属性、协议数据，合并到一个大数组中<br>
后面参与编译的Category数据，会在数组的前面</p>
<p>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</p>
<h3 id="类扩展和分类的区别">类扩展和分类的区别</h3>
<p>类扩展 编译的时候 就已经合并在类中了 无非将.h里公开声明里的东西变成.m里私有的<br>
<img src="http://localhost:4000/post-images/1639383526599.png" alt="" loading="lazy"><br>
分类是运行时机制 再将分类的东西合并到类里面</p>
<p><img src="http://localhost:4000/post-images/1639387605285.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1639387680149.png" alt="" loading="lazy"></p>
<h3 id="memmove和memcpy">memmove和memcpy</h3>
<p>1234 -&gt; 0124<br>
memmove  直接可以<br>
memcpy 变成0114</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 底层]]></title>
        <id>http://localhost:4000/post/ios-di-ceng/</id>
        <link href="http://localhost:4000/post/ios-di-ceng/">
        </link>
        <updated>2021-12-05T08:12:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="加壳">加壳</h3>
<p>从AppStore下载的App，会被加密<br>
利用特殊的算法，对我们可执行文件的编码进行改变</p>
<p>壳程序里面有（可执行文件（已加密））———&gt; 执行到———&gt;内存中（壳程序里面有（可执行文件（已加密）））———&gt;解密 ———&gt;内存中（壳程序里面有（可执行文件（解密）））</p>
<p>脱壳<br>
硬脱壳： 通过解密算法 从壳程序里解出可执行文件<br>
动态脱壳：当壳程序执行到内存中解密出可执行文件 ，我们从内存中拿到解密后的可执行文件</p>
<h3 id="ios签名机制">iOS签名机制</h3>
<p>加密方法有两个</p>
<ul>
<li>对称密码 加密和解密用的同一个密钥</li>
<li>非对称密码（公钥密码）加密和解密用的密钥是不一样的<br>
密钥 56bit</li>
</ul>
<h3 id="对称密码">对称密码：</h3>
<p>**DES ** 只能加密64bit的明文 已经被破解<br>
<strong>3DES</strong> 3DES，将DES重复3次所得到的一种密码算法，也叫做3重DES 目前还被一些银行等机构使用，但处理速度不高，安全性逐渐暴露出问题<br>
<strong>AES</strong> 取代DES成为新标准的一种对称密码算法 它经过了全世界密码学家所进行的高品质验证工作</p>
<h3 id="如何解决密钥配送问题">如何解决密钥配送问题</h3>
<p>有以下几种解决密钥配送的方法</p>
<ul>
<li>事先共享密钥</li>
<li>密钥分配中心</li>
<li>Diffie-Hellman密钥交换</li>
</ul>
<h3 id="公钥密码">公钥密码</h3>
<p>公钥密码中，密钥分为加密密钥、解密密钥2种，它们并不是同一个密钥<br>
加密密钥，一般是公开的，因此该密钥称为公钥（public key）<br>
解密密钥，由消息接收者自己保管的，不能公开，因此也称为私钥（private key）<br>
公钥和私钥是一 一对应的，是不能单独生成的，一对公钥和密钥统称为密钥对（key pair）<br>
由公钥加密的密文，必须使用与该公钥对应的私钥才能解密<br>
由私钥加密的密文，必须使用与该私钥对应的公钥才能解密<br>
<img src="http://localhost:4000/post-images/1638709484493.png" alt="" loading="lazy"><br>
目前使用最广泛的公钥密码算法是RSA</p>
<h3 id="解决密钥配送问题">解决密钥配送问题</h3>
<p>由消息的接收者，生成一对公钥、私钥<br>
将公钥发给消息的发送者<br>
消息的发送者使用公钥加密消息</p>
<p>对称密码的缺点<br>
不能很好地解决密钥配送问题</p>
<p>公钥密码的缺点<br>
加密解密速度比较慢</p>
<p>混合密码系统，是将对称密码和公钥密码的优势相结合的方法<br>
解决了公钥密码速度慢的问题<br>
并通过公钥密码解决了对称密码的密钥配送问题</p>
<p>网络上的密码通信所用的SSL/TLS都运用了混合密码系统</p>
<h3 id="混合密码-加密">混合密码-加密</h3>
<p><img src="http://localhost:4000/post-images/1638710695280.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1638710701498.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 签名机制]]></title>
        <id>http://localhost:4000/post/ios-qian-ming-ji-zhi/</id>
        <link href="http://localhost:4000/post/ios-qian-ming-ji-zhi/">
        </link>
        <updated>2021-12-05T08:12:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="加壳">加壳</h3>
<p>从AppStore下载的App，会被加密<br>
利用特殊的算法，对我们可执行文件的编码进行改变</p>
<p>壳程序里面有（可执行文件（已加密））———&gt; 执行到———&gt;内存中（壳程序里面有（可执行文件（已加密）））———&gt;解密 ———&gt;内存中（壳程序里面有（可执行文件（解密）））</p>
<p>脱壳<br>
硬脱壳： 通过解密算法 从壳程序里解出可执行文件<br>
动态脱壳：当壳程序执行到内存中解密出可执行文件 ，我们从内存中拿到解密后的可执行文件</p>
<h3 id="ios签名机制">iOS签名机制</h3>
<p>加密方法有两个</p>
<ul>
<li>对称密码 加密和解密用的同一个密钥</li>
<li>非对称密码（公钥密码）加密和解密用的密钥是不一样的<br>
密钥 56bit</li>
</ul>
<h3 id="对称密码">对称密码：</h3>
<p>**DES ** 只能加密64bit的明文 已经被破解<br>
<strong>3DES</strong> 3DES，将DES重复3次所得到的一种密码算法，也叫做3重DES 目前还被一些银行等机构使用，但处理速度不高，安全性逐渐暴露出问题<br>
<strong>AES</strong> 取代DES成为新标准的一种对称密码算法 它经过了全世界密码学家所进行的高品质验证工作</p>
<h3 id="如何解决密钥配送问题">如何解决密钥配送问题</h3>
<p>有以下几种解决密钥配送的方法</p>
<ul>
<li>事先共享密钥</li>
<li>密钥分配中心</li>
<li>Diffie-Hellman密钥交换</li>
</ul>
<h3 id="公钥密码">公钥密码</h3>
<p>公钥密码中，密钥分为加密密钥、解密密钥2种，它们并不是同一个密钥<br>
加密密钥，一般是公开的，因此该密钥称为公钥（public key）<br>
解密密钥，由消息接收者自己保管的，不能公开，因此也称为私钥（private key）<br>
公钥和私钥是一 一对应的，是不能单独生成的，一对公钥和密钥统称为密钥对（key pair）<br>
由公钥加密的密文，必须使用与该公钥对应的私钥才能解密<br>
由私钥加密的密文，必须使用与该私钥对应的公钥才能解密<br>
<img src="http://localhost:4000/post-images/1638709484493.png" alt="" loading="lazy"><br>
目前使用最广泛的公钥密码算法是RSA</p>
<h3 id="解决密钥配送问题">解决密钥配送问题</h3>
<p>由消息的接收者，生成一对公钥、私钥<br>
将公钥发给消息的发送者<br>
消息的发送者使用公钥加密消息</p>
<p>对称密码的缺点<br>
不能很好地解决密钥配送问题</p>
<p>公钥密码的缺点<br>
加密解密速度比较慢</p>
<p>混合密码系统，是将对称密码和公钥密码的优势相结合的方法<br>
解决了公钥密码速度慢的问题<br>
并通过公钥密码解决了对称密码的密钥配送问题</p>
<p>网络上的密码通信所用的SSL/TLS都运用了混合密码系统</p>
<h3 id="混合密码-加密">混合密码-加密</h3>
<p><img src="http://localhost:4000/post-images/1638710695280.png" alt="" loading="lazy"><br>
<img src="http://localhost:4000/post-images/1638710701498.png" alt="" loading="lazy"></p>
<h3 id="单向散列函数">单向散列函数</h3>
<p>单向散列函数，可以根据根据消息内容计算出散列值<br>
散列值的长度和消息的长度无关，无论消息是1bit、10M、100G，单向散列函数都会计算出固定长度的散列值</p>
<ul>
<li>根据任意长度的消息，计算出固定长度的散列值</li>
<li>计算速度快，能快速计算出散列值</li>
<li>消息不同，散列值也不同</li>
<li>具备单向性</li>
</ul>
<h3 id="数字签名">数字签名</h3>
<p><img src="http://localhost:4000/post-images/1638873958154.png" alt="" loading="lazy"><br>
数字签名不能保证机密性？<br>
数字签名的作用不是为了保证机密性，仅仅是为了能够识别内容有没有被篡改</p>
<p>数字签名的作用<br>
确认消息的完整性<br>
识别消息是否被篡改<br>
防止消息发送人否认</p>
<h3 id="数字签名无法解决的问题">数字签名无法解决的问题</h3>
<p>要正确使用签名，前提是<br>
用于验证签名的公钥必须属于真正的发送者</p>
<p>如果遭遇了中间人攻击，那么<br>
公钥将是伪造的<br>
数字签名将失效</p>
<p>所以在验证签名之前，首先得先验证公钥的合法性</p>
<p>如何验证公钥的合法性？<br>
证书<br>
<img src="http://localhost:4000/post-images/1638876813483.png" alt="" loading="lazy"><br>
密码学中的证书，全称叫公钥证书（Public-key Certificate，PKC），跟驾驶证类似<br>
里面有姓名、邮箱等个人信息，以及此人的公钥<br>
并由认证机构（Certificate Authority，CA）施加数字签名</p>
<p>CA就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织<br>
<img src="http://localhost:4000/post-images/1638878379794.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1638878575199.png" alt="" loading="lazy"></figure>
<h3 id="ios签名机制-流程图">iOS签名机制 – 流程图</h3>
<p><img src="http://localhost:4000/post-images/1638881402683.png" alt="" loading="lazy"><br>
安装</p>
<ul>
<li>1.Mac私钥签名App 生成  -》（App和App内容签名）</li>
<li>2.App私钥签名 Mac公钥 生成  -》（Mac公钥和Mac公钥签名）</li>
<li>3.App私钥签名 （Mac公钥和Mac公钥签名）+ Devices + app id + entitlements 生成 -》 （（Mac公钥和Mac公钥签名）+ Devices + app id + entitlements 和 签名）<br>
验证</li>
<li>App公钥验证安装3的签名 和 安装3的内容验证</li>
<li>核实Devices + app id + entitlements</li>
<li>App公钥验证安装2的签名获取 Mac公钥</li>
<li>Mac公钥 验证安装1的签名 核实App内容</li>
</ul>
<p>签名机制就是为了验证App不被人篡改</p>
<p>CertificateSigningRequest.certSigningRequest文件<br>
就是Mac设备的公钥</p>
<p>ios_development.cer、ios_distribution.cer文件<br>
利用Apple后台的私钥，对Mac设备的公钥进行签名后的证书文件  安装2</p>
<p>生成mobileprovision 选择设备、证书  安装3</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1638883511070.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 定时器]]></title>
        <id>http://localhost:4000/post/ios-ji-shi-qi/</id>
        <link href="http://localhost:4000/post/ios-ji-shi-qi/">
        </link>
        <updated>2021-11-25T03:21:58.000Z</updated>
        <content type="html"><![CDATA[<p><img src="http://localhost:4000/post-images/1637810663803.png" alt="" loading="lazy"><br>
self 对Timer是强引用 Timer对self是弱引用</p>
<h3 id="nstimer-循环引用">NSTimer 循环引用</h3>
<pre><code>self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
</code></pre>
<p>self 对Timer是强引用 Timer对self是强引用</p>
<p>更改为以下代码：</p>
<pre><code>self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[MJProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
</code></pre>
<pre><code>@interface MJProxy : NSObject
+ (instancetype)proxyWithTarget:(id)target;
@property (weak, nonatomic) id target;
@end
</code></pre>
<pre><code>+ (instancetype)proxyWithTarget:(id)target
{
    MJProxy *proxy = [[MJProxy alloc] init];
    proxy.target = target;
    return proxy;
}

- (id)forwardingTargetForSelector:(SEL)aSelector
{
    return self.target;
}

@end
</code></pre>
<p><img src="http://localhost:4000/post-images/1637824068622.png" alt="" loading="lazy"><br>
Timer对OtherObject是强引用 OtherObject对self是弱引用 self 对Timer是强引用<br>
self 释放了 timer释放了 OtherObject释放了</p>
<h3 id="nsproxy">NSProxy</h3>
<p>继承NSProxy类 不需要init 专门用来做消息转发<br>
直接做消息转发 不会先从父类找方法 因为没有方法</p>
<pre><code>+ (instancetype)proxyWithTarget:(id)target
{
    // NSProxy对象不需要调用init，因为它本来就没有init方法
    MJProxy *proxy = [MJProxy alloc];
    proxy.target = target;
    return proxy;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel
{
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [invocation invokeWithTarget:self.target];
}
@end
</code></pre>
<pre><code>@interface MJProxy : NSProxy
+ (instancetype)proxyWithTarget:(id)target;
@property (weak, nonatomic) id target;
@end
</code></pre>
<p>如果MJProxy MJProxy1有test方法则直接实现</p>
<h3 id="gcd定时器">GCD定时器</h3>
<p>NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时</p>
<p>而GCD的定时器会更加准时<br>
GCD和内核挂钩</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CAShapeLayer]]></title>
        <id>http://localhost:4000/post/cashapelayer/</id>
        <link href="http://localhost:4000/post/cashapelayer/">
        </link>
        <updated>2021-11-24T07:39:49.000Z</updated>
        <content type="html"><![CDATA[<p>关于CAShapeLayer和DrawRect的比较</p>
<p>DrawRect：DrawRect属于CoreGraphic框架，占用CPU，消耗性能大<br>
CAShapeLayer：CAShapeLayer属于CoreAnimation框架，通过GPU来渲染图形，节省性能。动画渲染直接提交给手机GPU，不消耗内存</p>
<h3 id="布局">布局</h3>
<p>要分析CALayer的anchorPoint和position属性,首先要讨论一下CALayer的布局.<br>
我们所熟悉的UIView有三个重要的布局属性:frame,bounds和center,CALayer对应的叫做 frame,bounds和position.</p>
<p>frame代表了图层的外部坐标(在父图层上占据的空间)<br>
bounds为内部坐标<br>
position代表了相对父图层anchorPoint的位置</p>
<h3 id="锚点">锚点</h3>
<ul>
<li>和position共同决定图层相对父图层的位置,即frame的x,y</li>
<li>在图层旋转时的固定点<br>
锚点使用单位坐标来描述,范围为左上角{0, 0}到右下角{1, 1},默认坐标是{0.5, 0.5}.</li>
</ul>
<h3 id="锚点和position的关系">锚点和position的关系</h3>
<p>position是图层的anchorPoint在父图层中的位置坐标.<br>
anchorPoint和position共同决定图层相对父图层的位置,即frame属性的frame.origin.<br>
单方面修改anchorPoint或者position并不会对彼此产生影响,修改其中一个值,受影响的只会是frame.origin.<br>
anchorPoint如果是0.5，0。5 就相当于 中心点 那可以理解成 子view的中心点在父view的位置坐标</p>
<p>position.x =  frame.origin.x - anchorPoint.x * bounds.size.width；</p>
<p>position.y =  frame.origin.y - anchorPoint.y * bounds.size.height</p>
<h3 id="总结">总结</h3>
<p>单方面修改anchorPoint或者position并不会对彼此产生影响,修改其中一个值,受影响的只会是frame.origin.</p>
<p>anchorPoint和position共同决定了frame<br>
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；<br>
frame.origin.y = position.y - anchorPoint.y * bounds.size.height</p>
<p>anchorPoint是图层在旋转时的固定点</p>
<p>https://www.jianshu.com/p/998a6119a275</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 多线程]]></title>
        <id>http://localhost:4000/post/ios-duo-xian-cheng/</id>
        <link href="http://localhost:4000/post/ios-duo-xian-cheng/">
        </link>
        <updated>2021-10-22T03:46:39.000Z</updated>
        <content type="html"><![CDATA[<pre><code>// 题目：写出NSLog的打印结果（来自美团 GCD 面试题）
__block int a = 0;
while (a &lt; 5) {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        a++;
    });
}
NSLog(@&quot;输出: %d&quot;, a);

// 答案：
// 输出结果为：a &gt;= 5
// 原因：while循环内部执行并发耗时任务，ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，所以当执行a++时，Block外部也能访问到改变后的值；当a不满足循环条件而跳出时，并发任务可能仍在只执行，此时仍然会改变a的值，鉴于不同机器的CPU和线程差异影响，所以最终输出结果会大于等于5
// 注意：a的输出值结果是a&gt;=5，但是a的实际结果会远远大于5（NSLog输出完成后，并发耗时任务可能尚未完全结束）
</code></pre>
<h3 id="gcdgrand-central-dispatch">GCD（Grand Central Dispatch）</h3>
<p>Grand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的解决方法，基本概念就是<strong>dispatch queue（调度队列）</strong>，queue 是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue 可以是并发的或串行的。GCD 的底层依然是用线程实现，不过我们可以不用关注实现的细节。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程被创建的问题。</p>
<p>GCD 可用于多核的并行运算<br>
GCD 会自动利用更多的CPU内核（比如双核、四核）<br>
GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）<br>
任务都是以block 的方式提交到对列上，然后 GCD 会自动的创建线程池去执行这些任务</p>
<h3 id="dispatchqueue">DispatchQueue</h3>
<p>一个对象，用于在应用程序的主线程或后台线程上串行或并发地管理任务的执行。<br>
DispatchQueue 是一个类似线程的概念，这里称作对列队列是一个 FIFO(先进先出，后进后出) 数据结构，意味着先提交到队列的任务会先开始执行。DispatchQueue 背后是一个由系统管理的线程池。</p>
<pre><code>同步和异步的区别
    同步（`sync`）：只能在当前线程中执行任务，不具备开启新线程的能力
    异步 (`async`)：可以在新的线程中执行任务，具备开启新线程的能力
</code></pre>
<h3 id="dispatchqos-quality-of-service-服务质量">DispatchQoS (quality of service) 服务质量</h3>
<p>适用于任务的服务质量或执行优先级。</p>
<p>优先级由最低的 background 到最高的 userInteractive 共五个，还有一个为定义的 unspecified.</p>
<ul>
<li>background：最低优先级，等同于 DISPATCH_QUEUE_PRIORITY_BACKGROUND. 用户不可见，比如：在后台存储大量数据</li>
<li>utility：优先级等同于 DISPATCH_QUEUE_PRIORITY_LOW，可以执行很长时间，再通知用户结果。比如：下载一个大文件，网络，计算</li>
<li>default：默认优先级,优先级等同于 DISPATCH_QUEUE_PRIORITY_DEFAULT，建议大多数情况下使用默认优先级</li>
<li>userInitiated：优先级等同于 DISPATCH_QUEUE_PRIORITY_HIGH,需要立刻的结果</li>
<li>userInteractive：用户交互相关，为了好的用户体验，任务需要立马执行。使用该优先级用于 UI 更新，事件处理和小工作量任务，在主线程执行<br>
Qos指定了列队工作的优先级，系统会根据优先级来调度工作，越高的优先级能够越快被执行，但是也会消耗功能，所以准确的指定优先级能够保证app有效的使用资源。+</li>
</ul>
<h3 id="dispatchworkitem">DispatchWorkItem</h3>
<p>想要执行的工作以某种方式进行封装，使您可以附加完成句柄或执行依赖项。通俗的说就是 DispatchWorkItem 把任务封装成一个对象。</p>
<pre><code>let item = DispatchWorkItem {
        // 任务
    }
    DispatchQueue.global().async(execute: item)
</code></pre>
<h3 id="dispatchgroup">DispatchGroup</h3>
<pre><code>func enterLeaveGroup() {
        let group = DispatchGroup()
        let queue = DispatchQueue.global()
       
        // 把该任务添加到组队列中执行
        group.enter()
        queue.async(group: group, qos: .default, flags: []) {
            // 增加耗时
            DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: {
                 for _ in 0...4 {
                     print(&quot;(Thread.current) 耗时任务一&quot;)
                 }
                // 执行完之后从组队列中移除
                group.leave()
            })
           
        }
       
        // 把该任务添加到组队列中执行
        group.enter()
        queue.async(group: group, qos: .default, flags: []) {
            for _ in 0...4 {
                print(&quot;(Thread.current) 耗时任务二&quot;)
            }
            // 执行完之后从组队列中移除
            group.leave()
        }
       
        // 当上面所有的任务执行完之后通知
        group.notify(queue: queue) {
            print(&quot;(Thread.current) 所有的任务执行完了&quot;)
        }
    }
   
    /* 输出结果
&lt;NSThread: 0x6000013dd980&gt;{number = 6, name = (null)} 耗时任务二
&lt;NSThread: 0x6000013dd980&gt;{number = 6, name = (null)} 耗时任务二
&lt;NSThread: 0x6000013dd980&gt;{number = 6, name = (null)} 耗时任务二
&lt;NSThread: 0x6000013dd980&gt;{number = 6, name = (null)} 耗时任务二
&lt;NSThread: 0x6000013dd980&gt;{number = 6, name = (null)} 耗时任务二
&lt;NSThread: 0x6000013862c0&gt;{number = 1, name = main} 耗时任务一
&lt;NSThread: 0x6000013862c0&gt;{number = 1, name = main} 耗时任务一
&lt;NSThread: 0x6000013862c0&gt;{number = 1, name = main} 耗时任务一
&lt;NSThread: 0x6000013862c0&gt;{number = 1, name = main} 耗时任务一
&lt;NSThread: 0x6000013862c0&gt;{number = 1, name = main} 耗时任务一
&lt;NSThread: 0x6000013ea2c0&gt;{number = 7, name = (null)} 所有的任务执行完了
    */
</code></pre>
<h3 id="suspend-resume">Suspend / Resume</h3>
<p>Suspend 可以挂起一个线程，即暂停线程，但是仍然占用资源，只是不执行</p>
<p>Resume 恢复线程，即继续执行挂起的线程。</p>
<h3 id="gcd与nsopration的区别">GCD与NSOpration的区别</h3>
<p>设置依赖关系<br>
设置监听进度<br>
设置优先级<br>
还能继承<br>
可以取消准备执行的任务<br>
比GCD会带来一点额外的系统开销<br>
比GCD更简单易用、代码可读性也更高</p>
<h3 id="nsoperation">NSOperation</h3>
<p>NSOperation是一个和任务相关的抽象类，不具备封装操作的能力，必须使用其子类。</p>
<p>NSOperation⼦类的方式有3种：</p>
<p>系统实现的具体子类：NSInvocationOperation<br>
系统实现的具体子类：NSBlockOperation<br>
自定义子类，实现内部相应的⽅法。该类是线程安全的，不必管理线程生命周期和同步等问题。</p>
<p>开启操作有二种方式，一是通过start方法直接启动操作，该操作默认同步执行，二是将操作添加到NSOperationQueue中，然后由系统从队列中获取操作然后添加到一个新线程中执行，这些操作默认并发执行。</p>
<p>具体实现<br>
方式一：直接由NSOperation子类对象启动。 首先将需要执行的操作封装到NSOperation子类对象中，然后该对象调用Start方法。<br>
方式二：当添加到NSOperationQueue对象中，由该队列对象启动操作。</p>
<ul>
<li>1.将需要执行的操作封装到NSOperation子类对象中</li>
<li>2.将该对象添加到NSOperationQueue中</li>
<li>3.系统将NSOperation子类对象从NSOperationQueue中取出</li>
<li>4.将取出的操作放到一个新线程中执行<br>
使用队列来执行操作，分为2个阶段：第一阶段：添加到线程队列的过程，是上面的步骤1和2。第二阶段：系统自动从队列中取出线程，并且自动放到线程中执行，是上面的步骤3和4。</li>
</ul>
<h3 id="nsinvocationoperation子类">NSInvocationOperation子类</h3>
<p>NSInvocationOperation类是NSOperation的一个具体子类，管理作为调用指定的<strong>单个封装任务执行</strong>的操作。这个类实现了一个<strong>非并发操作</strong>。方法属性无论使用该子类的哪个在初始化的方法，都会在添加一个任务。 和NSBlockOperation子类不同的是，因为没有额外添加任务的方法，<strong>使用NSInvocationOperation创建的对象只会有一个任务。</strong></p>
<p>创建操作对象的方式<br>
使用initWithTarget:selector:object:创建sel参数是一个或0个的操作对象<br>
使用initWithInvocation:方法，添加sel参数是0个或多个操作对象。<br>
在未添加到队列的情况下，创建操作对象的过程中不会开辟线程，会在当前线程中执行同步操作。创建完成后，直接调用start方法，会启动操作对象来执行，或者添加到NSOperationQueue队列中。</p>
<p><strong>默认情况</strong>下，调用start方法不会开辟一个新线程去执行操作，而是在当前线程<strong>同步执行</strong>任务。只有将其<strong>放到一个NSOperationQueue中</strong>，才会<strong>异步执行操作</strong>。</p>
<h3 id="nsblockoperation子类">NSBlockOperation子类</h3>
<p>NSBlockOperation类是NSOperation的一个具体子类，它管理一个或多个块的并发执行。可以使用此对象一次执行多个块，而不必为每个块创建单独的操作对象。当执行多个块时，只有当所有块都完成执行时，才认为操作本身已经完成。</p>
<p>添加到操作中的块(block)将以默认优先级分配到适当的工作队列。</p>
<h3 id="nsblockoperation子类-2">NSBlockOperation子类</h3>
<p>NSBlockOperation类是NSOperation的一个具体子类，它管理一个或多个块的并发执行。可以使用此对象一次执行多个块，而不必为每个块创建单独的操作对象。当执行多个块时，只有当所有块都完成执行时，才认为操作本身已经完成。</p>
<p>添加到操作中的块(block)将以默认优先级分配到适当的工作队列。</p>
<p>创建操作对象的方式<br>
可以通过blockOperationWithBlock:创建NSBlockOperation对象，在创建的时候也添加一个任务。如果想添加更多的任务，可以使用addExecutionBlock:方法。<br>
也可以通过init:创建NSBlockOperation对象。但是这种创建方式并不会在创建对象的时候添加任务，同样可以使用addExecutionBlock:方法添加任务。<br>
对于启动操作和NSInvocationOperation类一样，都可以通过调用start方法和添加NSOperationQueue中来执行操作。</p>
<h3 id="线程池">线程池</h3>
<p>线程池同理，正是因为每次创建、销毁线程需要占用太多系统资源，所以我们建这么一个池子来统一管理线程。用的时候从池子里拿，不用了就放回来，也不用你销毁</p>
<p><strong>线程池的好处</strong><br>
在多线程的第一篇文章中我们说过，进程会申请资源，拿来给线程用，所以线程是很占用系统资源的，那么我们用线程池来统一管理线程就能够很好的解决这种资源管理问题。</p>
<p>比如因为不需要创建、销毁线程，每次需要用的时候我就去拿，用完了之后再放回去，所以节省了很多资源开销，可以提高系统的运行速度。</p>
<p>而统一的管理和调度，可以合理分配内部资源，根据系统的当前情况调整线程的数量。</p>
<p>那总结来说有以下 3 个好处：</p>
<p>降低资源消耗：通过重复利用现有的线程来执行任务，避免多次创建和销毁线程。<br>
提高相应速度：因为省去了创建线程这个步骤，所以在拿到任务时，可以立刻开始执行。<br>
提供附加功能：线程池的可拓展性使得我们可以自己加入新的功能，比如说定时、延时来执行某些线程。</p>
<p>###线程同步、线程依赖、线程组<br>
https://www.cnblogs.com/chglog/p/6782413.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS AVFoundation 音视频剪辑和预览（合并、混音、插入、裁剪）]]></title>
        <id>http://localhost:4000/post/ios-avfoundation-yin-pin-jian-ji-he-yu-lan-he-bing-hun-yin-cha-ru-cai-jian/</id>
        <link href="http://localhost:4000/post/ios-avfoundation-yin-pin-jian-ji-he-yu-lan-he-bing-hun-yin-cha-ru-cai-jian/">
        </link>
        <updated>2021-09-28T03:47:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="音频合并">音频合并</h3>
<p>https://www.jianshu.com/p/fb063d592a3c</p>
<p>###音频剪切<br>
https://juejin.cn/post/6844903781662982158</p>
<p>###iOS视音频实用Demo<br>
https://www.twblogs.net/a/5b8ce6c72b7177188336bec1/?lang=zh-cn</p>
<h3 id="混合音频-修改音量">混合音频 修改音量</h3>
<p>https://www.shangmayuan.com/a/d6810fb117b24bef846b4ed7.html</p>
<h3 id="1-音视频资源组装">1、音视频资源组装</h3>
<p>在 AVFoundation 中，视频和音频数据可以用 AVAsset 表示，AVAsset 里面包含了 AVAssetTrack 数据。</p>
<p>比如：一个视频文件里面包含了一个视频 track 和两个音频 track。<br>
图：AVAsset 及其子类结构<br>
<img src="http://localhost:4000/post-images/1632813359808.jpeg" alt="" loading="lazy"></p>
<p>可以使用 AVComposition 对 track 进行裁剪和变速等操作，也可以把多段 track 拼接到 AVComposition 里面，在处理完 track 的拼接和修改后，得到最终的 AVComposition，它是 AVAsset 的子类，也就是说可以把它传递到 AVPlayer、AVAssetImageGenerator、AVExportSession 和 AVAssetReader 里面作为数据源，把 AVComposition 当成是一个视频数据进行处理。</p>
<h3 id="2-视频画面拼接混音处理">2、视频画面拼接/混音处理</h3>
<ul>
<li>AVFoundation 提供了 AVVideoComposition 对象和 AVVideoCompositing 协议用于处理视频的画面帧。<strong>使用 AVMutableComposition 类可以增删 AVAsset 来将单个或者多个 AVAsset 集合到一起，用来合成新视频</strong><br>
AVFoundation 类 API 中最核心的类是 AVVideoComposition / AVMutableVideoComposition 。</li>
</ul>
<p><strong>AVVideoComposition / AVMutableVideoComposition 对两个或多个视频轨道组合在一起的方法给出了一个总体描述</strong>。它由一组时间范围和描述组合行为的介绍内容组成。这些信息出现在组合资源内的任意时间点。</p>
<p>AVVideoComposition / AVMutableVideoComposition 管理所有视频轨道，可以决定最终视频的尺寸，裁剪需要在这里进行；</p>
<p><strong>AVMutableCompositionTrack 将多个 AVAsset 集合到一起合成新视频中轨道信息，有音频轨、视频轨等，里面可以插入各种对应的素材（画中画，水印等）；</strong></p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1632813569403.jpeg" alt="" loading="lazy"></figure>
<ul>
<li>2.2 AVFoundation 中的音频处理<br>
AVFoundation 提供了 AVAudioMix 用于处理音频数据。 AVAudioMix 这个类很简单，只有一个 inputParameters 属性，它是一个 AVAudioMixInputParameters 数组。具体的音频处理都在 AVAudioMixInputParameters 里进行配置。AVAudioMixInputParameters 只能绑定单个 AVAssetTrack 的音频数据。</li>
</ul>
<p>AVAudioMixInputParameters 内可以设置音量，支持分段设置音量，以及设置两个时间点的音量变化，比如 0 - 1 秒，音量大小从 0 - 1.0 线性递增。</p>
<p>AVAudioMixInputParameters 内还有个 audioTapProcessor 属性，他是一个 MTAudioProcessingTap 类。这个属性提供了接口用于实时处理音频数据。</p>
<blockquote>
<p>AVAsset 所有媒体资源的承载类。可以是音频，视频，图像。<br>
AVMutableComposition 用于组合AVAsset的音视频轨道。<br>
AVMutableCompositionTrack 分为视频轨道，音频轨道，它由AVAsset内部解码生成。<br>
AVMutableVideoComposition 视频编辑指令管理类，它是整个视频编辑里动画指令组合。<br>
AVMutableVideoCompositionInstruction 视频视图编辑指令，可以用它来设置视频的背景颜色等。它可以包含一组AVVideoCompositionLayerInstruction。<br>
AVMutableVideoCompositionLayerInstruction 视频层编辑指令，可以用它设置视频的transform,opacity等。</p>
</blockquote>
<p>https://zhuanlan.zhihu.com/p/369109995<br>
https://www.codersrc.com/archives/10539.html</p>
<h3 id="总结总体流程">总结总体流程</h3>
<p>AVFoundation 视频剪辑的整体工作流程：<br>
<img src="http://localhost:4000/post-images/1632815232101.png" alt="" loading="lazy"></p>
<p>拆解下步骤：</p>
<ul>
<li>1.创建一个或多个 AVAsset。</li>
<li>2.创建 AVComposition、AVVideoComposition 及 AVAudioMix。其中 AVComposition 指定了音视频轨道的时间对齐，AVVideoComposition 指定了视频轨道在任何给定时间点的几何变换与混合，AVAudioMix 管理音频轨道的混合参数。</li>
<li>我们可以使用这三个对象来创建 AVPlayerItem，并从中创建一个 AVPlayer 来播放编辑效果。</li>
<li>我们也可以使用这三个对象来创建 AVAssetExportSession，用来将编辑结果写入文件。</li>
</ul>
<h2 id="avcomposition">AVComposition</h2>
<p><strong>AVComposition</strong> 是一个或多个 AVCompositionTrack <strong>音视频轨道的集合</strong>。其中 <strong>AVCompositionTrack</strong> 又可以<strong>包含来自多个 AVAsset 的 AVAssetTrack</strong>。<br>
<img src="http://localhost:4000/post-images/1632815522710.png" alt="" loading="lazy"></p>
<h2 id="avvideocomposition">AVVideoComposition</h2>
<p>AVVideoComposition 可以用来指定渲染大小和渲染缩放，以及帧率。此外，还存储了实现 AVVideoCompositionInstructionProtocol 协议的 Instruction（指令）数组，这些 Instruction 存储了混合的参数。有了这些混合参数之后，AVVideoComposition 可以通过一个实现 AVVideoCompositing 协议的 Compositor（混合器） 来混合对应的图像帧。</p>
<p>整体工作流如下图所示：<br>
<img src="http://localhost:4000/post-images/1632815956180.png" alt="" loading="lazy"></p>
<h2 id="avaudiomix">AVAudioMix</h2>
<p>使用 AVAudioMix，你可以在 AVComposition 的音频轨道上处理音频。AVAudioMix 包含一组的 AVAudioMixInputParameters，每个 AVAudioMixInputParameters 对应一个音频的 AVCompositionTrack。如下图所示<br>
<img src="http://localhost:4000/post-images/1632816124491.png" alt="" loading="lazy"></p>
<p>https://xie.infoq.cn/article/9735e9fb133b5d294b175b4bd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GPUImage]]></title>
        <id>http://localhost:4000/post/gpuimage/</id>
        <link href="http://localhost:4000/post/gpuimage/">
        </link>
        <updated>2021-09-27T03:20:23.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.jianshu.com/p/fb8964955e24</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[音视频基础]]></title>
        <id>http://localhost:4000/post/yin-shi-pin-ji-chu/</id>
        <link href="http://localhost:4000/post/yin-shi-pin-ji-chu/">
        </link>
        <updated>2021-09-23T07:51:24.000Z</updated>
        <content type="html"><![CDATA[<p><strong>解协议</strong>的作用，就是将<strong>流媒体协议的数据</strong>，解析为标准的相应的<strong>封装格式数据</strong>。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会<strong>去除掉信令数据而只保留视音频数据</strong>。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p>
<p><strong>解封装</strong>的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p>
<p><strong>解码</strong>的作用，就是将视频/音频<strong>压缩编码数据</strong>，<strong>解码</strong>成为<strong>非压缩的视频/音频原始数据</strong>。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据</p>
<p><strong>视音频同步</strong>的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p>
<p>**流媒体开发:**网络层(socket或st)负责传输，协议层(rtmp或hls)负责网络打包，封装层(flv、ts)负责编解码数据的封装，编码层(h.264和aac)负责图像，音频压缩。<br>
帧:每帧代表一幅静止的图像</p>
<p><strong>GOP</strong>:（Group of Pictures）画面组，一个GOP就是一组连续的画面，每个画面都是一帧，一个GOP就是很多帧的集合<br>
直播的数据，其实是一组图片，包括I帧、P帧、B帧，当用户第一次观看的时候，会寻找I帧，而播放器会到服务器寻找到最近的I帧反馈给用户。因此，GOP Cache增加了端到端延迟，因为它必须要拿到最近的I帧<br>
GOP Cache的长度越长，画面质量越好</p>
<p><strong>视频封装格式</strong>：一种储存视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有MP4,MOV,AVI等，<br>
主要作用：一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.<br>
注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。</p>
<p><strong>视频压缩编码标准</strong>：对视频进行压缩(视频编码)或者解压缩（视频解码）的编码技术,比如MPEG，H.264,这些视频编码技术是压缩编码视频的<br>
主要作用:是将视频像素数据压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。<br>
注意:最影响视频质量的是其视频编码数据和音频编码数据，跟封装格式没有多大关系<br>
<strong>MPEG</strong>:一种视频压缩方式，它采用了帧间压缩，仅存储连续帧之间有差别的地方 ，从而达到较大的压缩比<br>
**H.264/AVC:**一种视频压缩方式,采用事先预测和与MPEG中的P-B帧一样的帧预测方法压缩，它可以根据需要产生适合网络情况传输的视频流,还有更高的压缩比，有更好的图象质量<br>
注意1:如果是从单个画面清晰度比较，MPEG4有优势；从动作连贯性上的清晰度，H.264有优势<br>
注意2:由于264的算法更加复杂，程序实现烦琐，运行它需要更多的处理器和内存资源。因此，运行264对系统要求是比较高的。<br>
注意3:由于264的实现更加灵活，它把一些实现留给了厂商自己去实现，虽然这样给实现带来了很多好处，但是不同产品之间互通成了很大的问题，造成了通过A公司的编码器编出的数据，必须通过A公司的解码器去解这样尴尬的事情</p>
<p>**H.265/HEVC:**一种视频压缩方式,基于H.264，保留原来的某些技术，同时对一些相关的技术加以改进，以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。<br>
H.265 是一种更为高效的编码标准，能够在同等画质效果下将内容的体积压缩得更小，传输时更快更省带宽<br>
<strong>I帧:</strong>(关键帧)保留一副完整的画面，解码时只需要本帧数据就可以完成（因为包含完整画面）</p>
<p><strong>P帧</strong>:(差别帧)保留这一帧跟之前帧的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>
<p><strong>B帧</strong>:(双向差别帧)保留的是本帧与前后帧的差别，解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累<br>
帧内（Intraframe）压缩:当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息,帧内一般采用有损压缩算法</p>
<p>**帧间（Interframe）压缩:**时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的</p>
<p><strong>muxing（合成）</strong>：将视频流、音频流甚至是字幕流封装到一个文件中(容器格式（FLV，TS）)，作为一个信号进行传输。一种视频压缩方式,基于H.264，保留原来的某些技术，同时对一些相关的技术加以改进，以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。</p>
<p><strong>流媒体服务器</strong></p>
<p>*** 5.1常用服务器 ***</p>
<p>SRS：一款国人开发的优秀开源流媒体服务器系统<br>
BMS:也是一款流媒体服务器系统，但不开源，是SRS的商业版，比SRS功能更多<br>
nginx:免费开源web服务器，常用来配置流媒体服务器。</p>
<ul>
<li>5.2数据分发 *</li>
</ul>
<p><strong>CDN：</strong>(Content Delivery Network)，即内容分发网络,将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度.<br>
CDN：代理服务器，相当于一个中介。<br>
CDN工作原理：比如请求流媒体数据<br>
1.上传流媒体数据到服务器（源站）<br>
2.源站存储流媒体数据<br>
3.客户端播放流媒体，向CDN请求编码后的流媒体数据<br>
4.CDN的服务器响应请求，若节点上没有该流媒体数据存在，则向源站继续请求流媒体数据；若节点上已经缓存了该视频文件，则跳到第6步。<br>
5.源站响应CDN的请求，将流媒体分发到相应的CDN节点上<br>
6.CDN将流媒体数据发送到客户端</p>
<p>**回源：**当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取搜索。如果没有人访问，那么CDN节点不会主动去源站拿.</p>
<p>**带宽:**在固定的时间可传输的数据总量，<br>
比如64位、800MHz的前端总线，它的数据传输率就等于64bit×800MHz÷8(Byte)=6.4GB/s</p>
<p><strong>负载均衡:</strong> 由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助.<br>
通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。<br>
均衡负载能够平均分配客户请求到服务器列阵，籍此提供快速获取重要数据，解决大量并发访问服务问题。<br>
这种群集技术可以用最少的投资获得接近于大型主机的性能。</p>
<p><strong>QoS（带宽管理</strong>）:限制每一个组群的带宽，让有限的带宽发挥最大的效用</p>
<p>https://www.cnblogs.com/oc-bowen/p/5895482.html</p>
<h3 id="yuv-的采样与格式">YUV 的采样与格式</h3>
<p>https://mp.weixin.qq.com/s/KKfkS5QpwPAdYcEwFAN9VA</p>
<h3 id="divx-avc-hevc格式的区别">DIVX、AVC、HEVC格式的区别</h3>
<p>DIVX格式：这种编码也就是早期的一种MEPG格式-4衍生出来的一种格式，也是我们通常说的DVDrip格式；<br>
AVC格式：（即H264格式）也是目前的主流视频压缩编码，不论是电脑，手机，硬盘播放器，高清盒子，都支持多H264的解码，这种格式的视频质量好，且兼容性很不错，是理想的视频编码格式，在不知道用哪种视频编码格式的时候选用这种一般是不会出问题的。<br>
HEVC格式：（H265格式）是当前最新的视频压缩编码，编码效率比H264有较大提升。可以说，同等文件大小，H265的视频质量最好；同等视频质量，H265的体积最小。但是，因为编码比较新，有些播放软件、高清播放机、高清盒子、智能电视、智能手机是不支持这种编码的。</p>
<h3 id="编码中的规格">编码中的规格</h3>
<p>https://blog.csdn.net/ameyume/article/details/6547923</p>
<h3 id="关于gop和帧率-码率的关系">关于GOP和帧率、码率的关系</h3>
<p>https://zhuanlan.zhihu.com/p/259870429</p>
<p>M值表示I帧或者P帧之间的帧数目，N值表示GOP的长度。如上图所示M = 1，则表示两个P帧相差1帧（无B帧），N = 30, 则表示GOP长度为30<br>
M = 1 IPPPPPPI P帧之间无B帧<br>
M = 3 IPBBPBBPI P帧之间两个B帧</p>
<h3 id="dts-pts-的概念">DTS、PTS 的概念</h3>
<p>DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。<br>
PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。<br>
需要注意的是：虽然 DTS、PTS 是用于指导播放端的行为，但它们是在编码的时候由编码器生成的。</p>
<p>当视频流中没有 B 帧时，通常 DTS 和 PTS 的顺序是一致的。但如果有 B 帧时，就回到了我们前面说的问题：解码顺序和播放顺序不一致了。</p>
<p>比如一个视频中，帧的显示顺序是：I B B P，现在我们需要在解码 B 帧时知道 P 帧中信息，因此这几帧在视频流中的顺序可能是：I P B B，这时候就体现出每帧都有 DTS 和 PTS 的作用了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。顺序大概如下：</p>
<p>PTS: 1 4 2 3<br>
DTS: 1 2 3 4<br>
Stream: I P B B</p>
<h3 id="ios-录播视频清晰度提升">iOS 录播视频清晰度提升</h3>
<p>https://toutiao.io/posts/zrh0ah/preview</p>
<h3 id="cmsamplebuffer深拷贝">CMSampleBuffer深拷贝</h3>
<p>https://www.jianshu.com/p/9fe6e76a289b<br>
https://qa.1r1g.com/sf/ask/2683475581/</p>
<h3 id="深入理解-cvpixelbufferref">深入理解 CVPixelBufferRef</h3>
<p>https://zhuanlan.zhihu.com/p/24762605</p>
]]></content>
    </entry>
</feed>